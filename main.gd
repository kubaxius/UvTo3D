extends Node3D

# Not very important, used only for visualisation.
@export var number_of_dots = 10000

@export_node_path("MeshInstance3D") var mesh_node

@onready var mesh:Mesh = get_node(mesh_node).mesh
@onready var thread = Thread.new()

var dot_step = 0

func _ready():
	VertexUtils.added_coordinate.connect(_coordinate_added)
	VertexUtils.finished_map.connect(_map_finished)


func _on_menu_start_pressed():
	# Calculates how often to create the green dots you see during generation.
	dot_step = int($Menu.uv_map_size.x * $Menu.uv_map_size.y / number_of_dots)
	
	var function: Callable
	if $Menu.sphere_mode:
		function = VertexUtils.get_uv_to_3d_coordinates_array.bind(mesh, $Menu.uv_map_size)
	else:
		function = VertexUtils.get_uv_to_3d_coordinates_array.bind(mesh, $Menu.uv_map_size, $Menu.sphere_radius)
	
	if $Menu.use_threading:
		thread.start(function)
	else:
		function.call()


func _process(_delta):
	$Menu.progress_bar.value = VertexUtils.percent


## Creates the green dots you see during map generation.
var counter = 0
func _coordinate_added(coordinate):
	if counter == dot_step:
		Draw3d.point(coordinate, 0.01, Color.GREEN)
		counter = 0
		return null
	counter += 1


func _map_finished():
	save_uv_3d_map()
	create_and_apply_noise_material()
	# remove the green dots
	$DrawingBoard.queue_free()
	$Menu.show_done_banner()
	# toggle rotation back on
	$Menu._on_check_box_toggled(true)


func _exit_tree():
	thread.wait_to_finish()


func save_uv_3d_map():
	var map = VertexUtils.map
	var file = FileAccess.open("res://"+$Menu.output_file_name, FileAccess.WRITE)
	
	file.store_string(var_to_str(map))


## Use this function if you want to restore arry from file.
func load_uv_3d_map():
	var text = FileAccess.open("res://planet/uv_3d_map.arr", FileAccess.READ).get_as_text()

	var uv_3d = str_to_var(text)
	return uv_3d


## Converts 3D noise to 2D map using info generated by this program.
## It just shows what can be done with this.
func create_and_apply_noise_material():
	var noise := FastNoiseLite.new()
	noise.noise_type = FastNoiseLite.TYPE_SIMPLEX
	noise.frequency = 0.5
	
	var uv_3d = VertexUtils.map
	var image := Image.create($Menu.uv_map_size.x, $Menu.uv_map_size.y, false, Image.FORMAT_RGB8)
	
	for x in uv_3d.size():
		for y in uv_3d[x].size():
			if typeof(uv_3d[x][y]) == TYPE_VECTOR3:
				var noise_val = noise.get_noise_3dv(uv_3d[x][y])
				var color = Color(noise_val, noise_val, noise_val)
				image.set_pixel(x, y, color)
	
	var material = StandardMaterial3D.new()
	material.albedo_texture = ImageTexture.create_from_image(image)
	mesh.surface_set_material(0, material)


# not finished
func create_image():
	# I thought I could encode positions into this image format, but I have no idea if it's
	# even possible from GDScript, lol
	var image = Image.create($Menu.uv_map_size.x, $Menu.uv_map_size.y, false, Image.FORMAT_RGBF)
